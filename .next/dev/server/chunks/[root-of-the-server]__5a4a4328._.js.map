{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/wemo/new-flow/A2V/lib/mcp-client.ts"],"sourcesContent":["// MCP客户端连接管理\nimport { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';\nimport { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';\n\n// 在 Node.js 环境中设置 EventSource polyfill\nif (typeof globalThis.EventSource === 'undefined') {\n    // eslint-disable-next-line @typescript-eslint/no-require-imports\n    const EventSourceModule = require('eventsource');\n    // eventsource 包导出的 EventSource 类在其 EventSource 属性中\n    const EventSourceConstructor = EventSourceModule.EventSource || EventSourceModule.default?.EventSource || EventSourceModule.default || EventSourceModule;\n    if (typeof EventSourceConstructor === 'function') {\n        globalThis.EventSource = EventSourceConstructor;\n    } else {\n        throw new Error('无法加载 EventSource polyfill');\n    }\n}\n\ninterface ClientData {\n    client: Client;\n    transport: StdioClientTransport | SSEClientTransport;\n}\n\n// 使用 globalThis 存储活跃的MCP客户端连接，避免开发模式热重载时丢失\n// 在 TypeScript 中需要声明 globalThis 的类型\ndeclare global {\n    // eslint-disable-next-line no-var\n    var __mcpActiveClients: Map<string, ClientData> | undefined;\n}\n\n// 获取或创建全局的 activeClients Map\nfunction getActiveClients(): Map<string, ClientData> {\n    if (typeof globalThis !== 'undefined') {\n        if (!globalThis.__mcpActiveClients) {\n            globalThis.__mcpActiveClients = new Map<string, ClientData>();\n            console.log('[MCP Client] 初始化全局连接存储');\n        }\n        return globalThis.__mcpActiveClients;\n    }\n    // 如果没有 globalThis，创建新的 Map（理论上不应该发生）\n    return new Map<string, ClientData>();\n}\n\n// 存储活跃的MCP客户端连接（通过函数访问，确保使用全局存储）\nexport const activeClients = {\n    get size() {\n        return getActiveClients().size;\n    },\n    get: (key: string) => getActiveClients().get(key),\n    set: (key: string, value: ClientData) => {\n        getActiveClients().set(key, value);\n        return getActiveClients();\n    },\n    has: (key: string) => getActiveClients().has(key),\n    delete: (key: string) => getActiveClients().delete(key),\n    clear: () => getActiveClients().clear(),\n    keys: () => getActiveClients().keys(),\n    values: () => getActiveClients().values(),\n    entries: () => getActiveClients().entries(),\n    forEach: (callbackfn: (value: ClientData, key: string, map: Map<string, ClientData>) => void) => {\n        getActiveClients().forEach(callbackfn);\n    },\n    [Symbol.iterator]: () => getActiveClients()[Symbol.iterator](),\n};\n\nexport async function connectMCP(\n    urlOrCommand: string,\n    args?: string[],\n    connectionId?: string\n): Promise<string> {\n    if (!urlOrCommand) {\n        throw new Error('缺少连接参数（URL 或命令）');\n    }\n\n    const client = new Client(\n        {\n            name: 'mcp-web-client',\n            version: '1.0.0',\n        },\n        {\n            capabilities: {\n                tools: {},\n                prompts: {},\n                resources: {},\n            },\n        }\n    );\n\n    let transport: StdioClientTransport | SSEClientTransport;\n\n    // 判断是 URL 还是命令行\n    if (urlOrCommand.startsWith('http://') || urlOrCommand.startsWith('https://')) {\n        // SSE 连接\n        try {\n            const url = new URL(urlOrCommand);\n\n            // 检测是否是前端页面 URL（包含 configId 或指向根路径的页面）\n            const isFrontendPage =\n                url.searchParams.has('configId') ||\n                url.pathname === '/' ||\n                url.pathname === '' ||\n                (!url.pathname.includes('/sse') && !url.pathname.includes('/mcp') && !url.pathname.includes('/api'));\n\n            if (isFrontendPage) {\n                const configId = url.searchParams.get('configId');\n                if (configId) {\n                    throw new Error(\n                        `您提供的是前端页面 URL，不是 MCP 服务器的 SSE 端点。\\n` +\n                        `如果您想使用配置 ID \"${configId}\" 连接，请使用以下方式之一：\\n` +\n                        `1. 访问 /config/${configId} 页面来自动连接\\n` +\n                        `2. 在\"配置管理\"中查看该配置的实际 MCP 服务器 URL\\n` +\n                        `3. 在连接表单中输入 MCP 服务器的 SSE URL（通常以 /sse 结尾）`\n                    );\n                } else {\n                    throw new Error(\n                        `您提供的是前端页面 URL，不是 MCP 服务器的 SSE 端点。\\n` +\n                        `请提供 MCP 服务器的 SSE URL（例如：https://mcp.example.com/sse）`\n                    );\n                }\n            }\n\n            transport = new SSEClientTransport(url);\n        } catch (error: any) {\n            // 如果是我们抛出的错误，直接抛出\n            if (error.message && (error.message.includes('前端页面') || error.message.includes('SSE 端点'))) {\n                throw error;\n            }\n            throw new Error(`无效的 URL: ${error.message}`);\n        }\n    } else {\n        // Stdio 连接（命令行）\n        if (!args) {\n            throw new Error('使用命令行连接时，必须提供 args 参数');\n        }\n        transport = new StdioClientTransport({\n            command: urlOrCommand,\n            args: args || [],\n        });\n    }\n\n    try {\n        await client.connect(transport);\n        // connect() 方法会自动处理初始化流程，无需手动调用 initialize()\n    } catch (error: any) {\n        // 如果是 SSE 连接失败，检查是否是内容类型错误\n        if (transport instanceof SSEClientTransport) {\n            const errorMessage = error.message || String(error);\n            if (errorMessage.includes('text/event-stream') || errorMessage.includes('Invalid content type')) {\n                throw new Error(\n                    `SSE 连接失败：服务器未返回正确的 SSE 流（text/event-stream）。\\n` +\n                    `这可能是因为：\\n` +\n                    `1. URL 不正确（您提供的是前端页面 URL 而不是 MCP SSE 端点）\\n` +\n                    `2. MCP 服务器未正确配置 SSE 端点\\n` +\n                    `3. URL 指向的不是 MCP 服务器\\n\\n` +\n                    `请确认您使用的是 MCP 服务器的 SSE URL（通常以 /sse 结尾）`\n                );\n            }\n        }\n        throw error;\n    }\n\n    const id = connectionId || `conn_${Date.now()}`;\n    const clientsMap = getActiveClients();\n    clientsMap.set(id, { client, transport });\n\n    console.log(`[MCP Client] 连接成功，ID: ${id}`);\n    console.log(`[MCP Client] 当前活跃连接数: ${clientsMap.size}`);\n    console.log(`[MCP Client] 所有连接ID:`, Array.from(clientsMap.keys()));\n\n    return id;\n}\n\nexport async function disconnectMCP(connectionId: string): Promise<void> {\n    const clientsMap = getActiveClients();\n    const clientData = clientsMap.get(connectionId);\n    if (!clientData) {\n        throw new Error('连接不存在');\n    }\n\n    const { client } = clientData;\n    await client.close();\n    clientsMap.delete(connectionId);\n    console.log(`[MCP Client] 已断开连接: ${connectionId}`);\n}\n\nexport function getClient(connectionId: string): Client {\n    const clientsMap = getActiveClients();\n    console.log(`[MCP Client] 查找连接: ${connectionId}`);\n    console.log(`[MCP Client] 当前活跃连接:`, Array.from(clientsMap.keys()));\n    console.log(`[MCP Client] 连接总数: ${clientsMap.size}`);\n\n    const clientData = clientsMap.get(connectionId);\n    if (!clientData) {\n        console.error(`[MCP Client] 连接不存在: ${connectionId}`);\n        console.error(`[MCP Client] 可用连接ID:`, Array.from(clientsMap.keys()));\n        throw new Error(`连接不存在: ${connectionId}`);\n    }\n\n    console.log(`[MCP Client] 找到连接: ${connectionId}`);\n    return clientData.client;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 220, "column": 0}, "map": {"version":3,"sources":["file:///Users/wemo/new-flow/A2V/app/api/connect/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { connectMCP } from '@/lib/mcp-client';\n\nexport async function POST(request: NextRequest) {\n    try {\n        const { url, command, args, connectionId, script } = await request.json();\n\n        let urlOrCommand: string | undefined;\n        let finalArgs: string[] | undefined;\n        let finalConnectionId = connectionId;\n\n        // 支持三种连接方式：\n        // 1. URL 连接（SSE）- 用于 FastGPT 等远程 MCP 服务器\n        // 2. 接入脚本（JSON）- 从 FastGPT 获取的完整配置脚本\n        // 3. 命令行连接（stdio）- 用于本地 MCP 服务器\n        if (script) {\n            // 解析接入脚本\n            try {\n                // script 可能是字符串（需要解析）或已经是对象\n                const scriptData = typeof script === 'string' ? JSON.parse(script) : script;\n\n                // 从脚本中提取连接信息\n                // FastGPT 的接入脚本通常包含 url 或 sse 字段\n                if (scriptData.url) {\n                    urlOrCommand = scriptData.url;\n                } else if (scriptData.sse) {\n                    urlOrCommand = scriptData.sse;\n                } else if (scriptData.server && scriptData.server.url) {\n                    urlOrCommand = scriptData.server.url;\n                } else {\n                    throw new Error('接入脚本中未找到有效的 URL 字段');\n                }\n\n                // 如果脚本中有连接 ID，使用它\n                if (scriptData.connectionId || scriptData.id) {\n                    finalConnectionId = scriptData.connectionId || scriptData.id;\n                }\n\n                // 如果脚本中有其他配置，可以在这里处理\n                console.log('解析接入脚本:', { url: urlOrCommand, connectionId: finalConnectionId });\n            } catch (parseError: any) {\n                return NextResponse.json(\n                    {\n                        success: false,\n                        error: '脚本解析失败',\n                        message: parseError.message || '无法解析接入脚本',\n                    },\n                    { status: 400 }\n                );\n            }\n        } else {\n            urlOrCommand = url || command;\n            finalArgs = args;\n        }\n\n        if (!urlOrCommand) {\n            return NextResponse.json(\n                {\n                    success: false,\n                    error: '缺少连接参数',\n                    message: '请提供 URL、命令或接入脚本',\n                },\n                { status: 400 }\n            );\n        }\n\n        // 检测是否是代理链接（格式：/api/proxy/[configId]/sse 或 http://.../api/proxy/[configId]/sse）\n        console.log('[Connect] 检查是否是代理链接...');\n        console.log(`  - urlOrCommand: ${urlOrCommand}`);\n        console.log(`  - 类型: ${typeof urlOrCommand}`);\n\n        if (urlOrCommand && typeof urlOrCommand === 'string') {\n            // 匹配 /api/proxy/[configId]/sse 格式（支持完整URL和相对路径）\n            const proxyUrlPattern = /\\/api\\/proxy\\/([^\\/]+)\\/sse/i;\n            const proxyMatch = urlOrCommand.match(proxyUrlPattern);\n\n            console.log(`  - 正则匹配结果:`, proxyMatch);\n\n            if (proxyMatch) {\n                const configId = proxyMatch[1];\n                console.log(`  ✅ [Connect] 检测到代理链接，configId: ${configId}`);\n\n                // 对于代理链接，返回一个特殊的连接ID格式：proxy_[configId]\n                // 前端可以通过这个ID识别是代理连接，并使用代理API端点\n                const proxyConnectionId = `proxy_${configId}`;\n                console.log(`  - 生成的 connectionId: ${proxyConnectionId}`);\n\n                return NextResponse.json({\n                    success: true,\n                    connectionId: proxyConnectionId,\n                    isProxy: true,\n                    configId: configId,\n                    message: '代理连接已识别，请使用代理API端点获取工具、资源和提示词',\n                });\n            } else {\n                console.log(`  ⚠️  [Connect] 不是代理链接格式`);\n            }\n        }\n\n        const id = await connectMCP(urlOrCommand, finalArgs, finalConnectionId);\n\n        return NextResponse.json({\n            success: true,\n            connectionId: id,\n            message: 'MCP服务器连接成功',\n        });\n    } catch (error: any) {\n        console.error('连接MCP服务器失败:', error);\n        return NextResponse.json(\n            {\n                success: false,\n                error: '连接失败',\n                message: error.message,\n            },\n            { status: 500 }\n        );\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,KAAK,OAAoB;IAC3C,IAAI;QACA,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,YAAY,EAAE,MAAM,EAAE,GAAG,MAAM,QAAQ,IAAI;QAEvE,IAAI;QACJ,IAAI;QACJ,IAAI,oBAAoB;QAExB,YAAY;QACZ,yCAAyC;QACzC,qCAAqC;QACrC,gCAAgC;QAChC,IAAI,QAAQ;YACR,SAAS;YACT,IAAI;gBACA,4BAA4B;gBAC5B,MAAM,aAAa,OAAO,WAAW,WAAW,KAAK,KAAK,CAAC,UAAU;gBAErE,aAAa;gBACb,iCAAiC;gBACjC,IAAI,WAAW,GAAG,EAAE;oBAChB,eAAe,WAAW,GAAG;gBACjC,OAAO,IAAI,WAAW,GAAG,EAAE;oBACvB,eAAe,WAAW,GAAG;gBACjC,OAAO,IAAI,WAAW,MAAM,IAAI,WAAW,MAAM,CAAC,GAAG,EAAE;oBACnD,eAAe,WAAW,MAAM,CAAC,GAAG;gBACxC,OAAO;oBACH,MAAM,IAAI,MAAM;gBACpB;gBAEA,kBAAkB;gBAClB,IAAI,WAAW,YAAY,IAAI,WAAW,EAAE,EAAE;oBAC1C,oBAAoB,WAAW,YAAY,IAAI,WAAW,EAAE;gBAChE;gBAEA,qBAAqB;gBACrB,QAAQ,GAAG,CAAC,WAAW;oBAAE,KAAK;oBAAc,cAAc;gBAAkB;YAChF,EAAE,OAAO,YAAiB;gBACtB,OAAO,qSAAY,CAAC,IAAI,CACpB;oBACI,SAAS;oBACT,OAAO;oBACP,SAAS,WAAW,OAAO,IAAI;gBACnC,GACA;oBAAE,QAAQ;gBAAI;YAEtB;QACJ,OAAO;YACH,eAAe,OAAO;YACtB,YAAY;QAChB;QAEA,IAAI,CAAC,cAAc;YACf,OAAO,qSAAY,CAAC,IAAI,CACpB;gBACI,SAAS;gBACT,OAAO;gBACP,SAAS;YACb,GACA;gBAAE,QAAQ;YAAI;QAEtB;QAEA,gFAAgF;QAChF,QAAQ,GAAG,CAAC;QACZ,QAAQ,GAAG,CAAC,CAAC,kBAAkB,EAAE,cAAc;QAC/C,QAAQ,GAAG,CAAC,CAAC,QAAQ,EAAE,OAAO,cAAc;QAE5C,IAAI,gBAAgB,OAAO,iBAAiB,UAAU;YAClD,gDAAgD;YAChD,MAAM,kBAAkB;YACxB,MAAM,aAAa,aAAa,KAAK,CAAC;YAEtC,QAAQ,GAAG,CAAC,CAAC,WAAW,CAAC,EAAE;YAE3B,IAAI,YAAY;gBACZ,MAAM,WAAW,UAAU,CAAC,EAAE;gBAC9B,QAAQ,GAAG,CAAC,CAAC,gCAAgC,EAAE,UAAU;gBAEzD,wCAAwC;gBACxC,+BAA+B;gBAC/B,MAAM,oBAAoB,CAAC,MAAM,EAAE,UAAU;gBAC7C,QAAQ,GAAG,CAAC,CAAC,sBAAsB,EAAE,mBAAmB;gBAExD,OAAO,qSAAY,CAAC,IAAI,CAAC;oBACrB,SAAS;oBACT,cAAc;oBACd,SAAS;oBACT,UAAU;oBACV,SAAS;gBACb;YACJ,OAAO;gBACH,QAAQ,GAAG,CAAC,CAAC,wBAAwB,CAAC;YAC1C;QACJ;QAEA,MAAM,KAAK,MAAM,IAAA,0JAAU,EAAC,cAAc,WAAW;QAErD,OAAO,qSAAY,CAAC,IAAI,CAAC;YACrB,SAAS;YACT,cAAc;YACd,SAAS;QACb;IACJ,EAAE,OAAO,OAAY;QACjB,QAAQ,KAAK,CAAC,eAAe;QAC7B,OAAO,qSAAY,CAAC,IAAI,CACpB;YACI,SAAS;YACT,OAAO;YACP,SAAS,MAAM,OAAO;QAC1B,GACA;YAAE,QAAQ;QAAI;IAEtB;AACJ","debugId":null}}]
}
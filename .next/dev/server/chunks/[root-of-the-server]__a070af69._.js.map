{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/wemo/new-flow/A2V/lib/mcp-client.ts"],"sourcesContent":["// MCP客户端连接管理\nimport { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';\nimport { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';\n\n// 在 Node.js 环境中设置 EventSource polyfill\nif (typeof globalThis.EventSource === 'undefined') {\n    // eslint-disable-next-line @typescript-eslint/no-require-imports\n    const EventSourceModule = require('eventsource');\n    // eventsource 包导出的 EventSource 类在其 EventSource 属性中\n    const EventSourceConstructor = EventSourceModule.EventSource || EventSourceModule.default?.EventSource || EventSourceModule.default || EventSourceModule;\n    if (typeof EventSourceConstructor === 'function') {\n        globalThis.EventSource = EventSourceConstructor;\n    } else {\n        throw new Error('无法加载 EventSource polyfill');\n    }\n}\n\ninterface ClientData {\n    client: Client;\n    transport: StdioClientTransport | SSEClientTransport;\n}\n\n// 使用 globalThis 存储活跃的MCP客户端连接，避免开发模式热重载时丢失\n// 在 TypeScript 中需要声明 globalThis 的类型\ndeclare global {\n    // eslint-disable-next-line no-var\n    var __mcpActiveClients: Map<string, ClientData> | undefined;\n}\n\n// 获取或创建全局的 activeClients Map\nfunction getActiveClients(): Map<string, ClientData> {\n    if (typeof globalThis !== 'undefined') {\n        if (!globalThis.__mcpActiveClients) {\n            globalThis.__mcpActiveClients = new Map<string, ClientData>();\n            console.log('[MCP Client] 初始化全局连接存储');\n        }\n        return globalThis.__mcpActiveClients;\n    }\n    // 如果没有 globalThis，创建新的 Map（理论上不应该发生）\n    return new Map<string, ClientData>();\n}\n\n// 存储活跃的MCP客户端连接（通过函数访问，确保使用全局存储）\nexport const activeClients = {\n    get size() {\n        return getActiveClients().size;\n    },\n    get: (key: string) => getActiveClients().get(key),\n    set: (key: string, value: ClientData) => {\n        getActiveClients().set(key, value);\n        return getActiveClients();\n    },\n    has: (key: string) => getActiveClients().has(key),\n    delete: (key: string) => getActiveClients().delete(key),\n    clear: () => getActiveClients().clear(),\n    keys: () => getActiveClients().keys(),\n    values: () => getActiveClients().values(),\n    entries: () => getActiveClients().entries(),\n    forEach: (callbackfn: (value: ClientData, key: string, map: Map<string, ClientData>) => void) => {\n        getActiveClients().forEach(callbackfn);\n    },\n    [Symbol.iterator]: () => getActiveClients()[Symbol.iterator](),\n};\n\nexport async function connectMCP(\n    urlOrCommand: string,\n    args?: string[],\n    connectionId?: string\n): Promise<string> {\n    if (!urlOrCommand) {\n        throw new Error('缺少连接参数（URL 或命令）');\n    }\n\n    const client = new Client(\n        {\n            name: 'mcp-web-client',\n            version: '1.0.0',\n        },\n        {\n            capabilities: {\n                tools: {},\n                prompts: {},\n                resources: {},\n            },\n        }\n    );\n\n    let transport: StdioClientTransport | SSEClientTransport;\n\n    // 判断是 URL 还是命令行\n    if (urlOrCommand.startsWith('http://') || urlOrCommand.startsWith('https://')) {\n        // SSE 连接\n        try {\n            const url = new URL(urlOrCommand);\n\n            // 检测是否是前端页面 URL（包含 configId 或指向根路径的页面）\n            const isFrontendPage =\n                url.searchParams.has('configId') ||\n                url.pathname === '/' ||\n                url.pathname === '' ||\n                (!url.pathname.includes('/sse') && !url.pathname.includes('/mcp') && !url.pathname.includes('/api'));\n\n            if (isFrontendPage) {\n                const configId = url.searchParams.get('configId');\n                if (configId) {\n                    throw new Error(\n                        `您提供的是前端页面 URL，不是 MCP 服务器的 SSE 端点。\\n` +\n                        `如果您想使用配置 ID \"${configId}\" 连接，请使用以下方式之一：\\n` +\n                        `1. 访问 /config/${configId} 页面来自动连接\\n` +\n                        `2. 在\"配置管理\"中查看该配置的实际 MCP 服务器 URL\\n` +\n                        `3. 在连接表单中输入 MCP 服务器的 SSE URL（通常以 /sse 结尾）`\n                    );\n                } else {\n                    throw new Error(\n                        `您提供的是前端页面 URL，不是 MCP 服务器的 SSE 端点。\\n` +\n                        `请提供 MCP 服务器的 SSE URL（例如：https://mcp.example.com/sse）`\n                    );\n                }\n            }\n\n            transport = new SSEClientTransport(url);\n        } catch (error: any) {\n            // 如果是我们抛出的错误，直接抛出\n            if (error.message && (error.message.includes('前端页面') || error.message.includes('SSE 端点'))) {\n                throw error;\n            }\n            throw new Error(`无效的 URL: ${error.message}`);\n        }\n    } else {\n        // Stdio 连接（命令行）\n        if (!args) {\n            throw new Error('使用命令行连接时，必须提供 args 参数');\n        }\n        transport = new StdioClientTransport({\n            command: urlOrCommand,\n            args: args || [],\n        });\n    }\n\n    try {\n        await client.connect(transport);\n        // connect() 方法会自动处理初始化流程，无需手动调用 initialize()\n    } catch (error: any) {\n        // 如果是 SSE 连接失败，检查是否是内容类型错误\n        if (transport instanceof SSEClientTransport) {\n            const errorMessage = error.message || String(error);\n            if (errorMessage.includes('text/event-stream') || errorMessage.includes('Invalid content type')) {\n                throw new Error(\n                    `SSE 连接失败：服务器未返回正确的 SSE 流（text/event-stream）。\\n` +\n                    `这可能是因为：\\n` +\n                    `1. URL 不正确（您提供的是前端页面 URL 而不是 MCP SSE 端点）\\n` +\n                    `2. MCP 服务器未正确配置 SSE 端点\\n` +\n                    `3. URL 指向的不是 MCP 服务器\\n\\n` +\n                    `请确认您使用的是 MCP 服务器的 SSE URL（通常以 /sse 结尾）`\n                );\n            }\n        }\n        throw error;\n    }\n\n    const id = connectionId || `conn_${Date.now()}`;\n    const clientsMap = getActiveClients();\n    clientsMap.set(id, { client, transport });\n\n    console.log(`[MCP Client] 连接成功，ID: ${id}`);\n    console.log(`[MCP Client] 当前活跃连接数: ${clientsMap.size}`);\n    console.log(`[MCP Client] 所有连接ID:`, Array.from(clientsMap.keys()));\n\n    return id;\n}\n\nexport async function disconnectMCP(connectionId: string): Promise<void> {\n    const clientsMap = getActiveClients();\n    const clientData = clientsMap.get(connectionId);\n    if (!clientData) {\n        throw new Error('连接不存在');\n    }\n\n    const { client } = clientData;\n    await client.close();\n    clientsMap.delete(connectionId);\n    console.log(`[MCP Client] 已断开连接: ${connectionId}`);\n}\n\nexport function getClient(connectionId: string): Client {\n    const clientsMap = getActiveClients();\n    console.log(`[MCP Client] 查找连接: ${connectionId}`);\n    console.log(`[MCP Client] 当前活跃连接:`, Array.from(clientsMap.keys()));\n    console.log(`[MCP Client] 连接总数: ${clientsMap.size}`);\n\n    const clientData = clientsMap.get(connectionId);\n    if (!clientData) {\n        console.error(`[MCP Client] 连接不存在: ${connectionId}`);\n        console.error(`[MCP Client] 可用连接ID:`, Array.from(clientsMap.keys()));\n        throw new Error(`连接不存在: ${connectionId}`);\n    }\n\n    console.log(`[MCP Client] 找到连接: ${connectionId}`);\n    return clientData.client;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 220, "column": 0}, "map": {"version":3,"sources":["file:///Users/wemo/new-flow/A2V/app/api/resources/%5BconnectionId%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getClient } from '@/lib/mcp-client';\n\nexport async function GET(\n    request: NextRequest,\n    { params }: { params: Promise<{ connectionId: string }> | { connectionId: string } }\n) {\n    try {\n        // 处理 Next.js 15 中 params 可能是 Promise 的情况\n        const resolvedParams = params instanceof Promise ? await params : params;\n        const { connectionId } = resolvedParams;\n\n        if (!connectionId) {\n            return NextResponse.json(\n                {\n                    success: false,\n                    error: '缺少 connectionId 参数',\n                },\n                { status: 400 }\n            );\n        }\n\n        const client = getClient(connectionId);\n        const resources = await client.listResources();\n\n        return NextResponse.json({\n            success: true,\n            resources: resources.resources || [],\n        });\n    } catch (error: any) {\n        console.error('获取资源列表失败:', error);\n\n        // MCP 错误码 -32601 表示 \"Method not found\"，说明服务器不支持此功能\n        // 这是正常情况，返回空列表而不是错误\n        if (error.code === -32601 || error.message?.includes('Method not found')) {\n            console.log('MCP 服务器不支持 resources 功能，返回空列表');\n            return NextResponse.json({\n                success: true,\n                resources: [],\n                message: '该 MCP 服务器不支持资源功能',\n            });\n        }\n\n        return NextResponse.json(\n            {\n                success: false,\n                error: '获取资源列表失败',\n                message: error.message,\n            },\n            { status: 500 }\n        );\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,IAClB,OAAoB,EACpB,EAAE,MAAM,EAA4E;IAEpF,IAAI;QACA,yCAAyC;QACzC,MAAM,iBAAiB,kBAAkB,UAAU,MAAM,SAAS;QAClE,MAAM,EAAE,YAAY,EAAE,GAAG;QAEzB,IAAI,CAAC,cAAc;YACf,OAAO,qSAAY,CAAC,IAAI,CACpB;gBACI,SAAS;gBACT,OAAO;YACX,GACA;gBAAE,QAAQ;YAAI;QAEtB;QAEA,MAAM,SAAS,IAAA,yJAAS,EAAC;QACzB,MAAM,YAAY,MAAM,OAAO,aAAa;QAE5C,OAAO,qSAAY,CAAC,IAAI,CAAC;YACrB,SAAS;YACT,WAAW,UAAU,SAAS,IAAI,EAAE;QACxC;IACJ,EAAE,OAAO,OAAY;QACjB,QAAQ,KAAK,CAAC,aAAa;QAE3B,mDAAmD;QACnD,oBAAoB;QACpB,IAAI,MAAM,IAAI,KAAK,CAAC,SAAS,MAAM,OAAO,EAAE,SAAS,qBAAqB;YACtE,QAAQ,GAAG,CAAC;YACZ,OAAO,qSAAY,CAAC,IAAI,CAAC;gBACrB,SAAS;gBACT,WAAW,EAAE;gBACb,SAAS;YACb;QACJ;QAEA,OAAO,qSAAY,CAAC,IAAI,CACpB;YACI,SAAS;YACT,OAAO;YACP,SAAS,MAAM,OAAO;QAC1B,GACA;YAAE,QAAQ;QAAI;IAEtB;AACJ","debugId":null}}]
}
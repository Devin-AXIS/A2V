module.exports=[14747,(e,o,t)=>{o.exports=e.x("path",()=>require("path"))},47883,e=>{"use strict";function o(){return globalThis.__mcpProxySessions||(globalThis.__mcpProxySessions=new Map),globalThis.__mcpProxySessions}function t(e){if(!e.startsWith("proxy_"))throw Error(`不是代理连接ID: ${e}`);let t=e.replace("proxy_","");for(let[e,n]of(console.log(`[Proxy Client] 查找代理连接: ${t}`),o().entries()))if(n.configId===t&&n.mcpClient)return console.log(`[Proxy Client] 找到代理会话: ${e}, configId: ${t}`),n.mcpClient;throw Error(`代理会话不存在，configId: ${t}。请确保已通过代理SSE端点建立连接。`)}function n(e){return e.startsWith("proxy_")}function r(){let e=o(),t=new Set;for(let[o,n]of e.entries())n.configId&&n.mcpClient&&t.add(n.configId);return Array.from(t)}e.i(14747).default.join(process.cwd(),"data","mcp-configs","configs.json"),e.s(["getActiveProxyConfigIds",()=>r,"getProxyClient",()=>t,"isProxyConnection",()=>n])},29980,e=>{"use strict";var o=e.i(50820),t=e.i(14813),n=e.i(45637),r=e.i(54554),l=e.i(28638),s=e.i(63491),a=e.i(87089),i=e.i(92687),c=e.i(27486),u=e.i(90620),d=e.i(87386),p=e.i(39271),g=e.i(29558),h=e.i(95727),f=e.i(13230),m=e.i(17143),w=e.i(93695);e.i(59715);var x=e.i(26753),v=e.i(61056),R=e.i(23718),y=e.i(47883);async function C(o){console.log("\n========== [Call Tool API] 请求开始 ==========");try{let t,{connectionId:n,toolName:r,arguments:l,walletAddress:s}=await o.json();if(console.log(`[Call Tool] 接收到的参数:`),console.log(`  - connectionId: ${n}`),console.log(`  - toolName: ${r}`),console.log(`  - walletAddress: ${s||"未提供"}`),console.log(`  - toolArgs: ${JSON.stringify(l||{})}`),!n||!r)return console.error(`  ❌ 缺少必需参数: connectionId=${!!n}, toolName=${!!r}`),v.NextResponse.json({error:"缺少connectionId或toolName参数"},{status:400});let a=(0,y.isProxyConnection)(n),i=n;if(!a){if(console.log(`  [Call Tool] connectionId 不是 proxy_ 格式，尝试识别代理连接...`),/^[a-f0-9]{32}$/i.test(n)){console.log(`  - 检测到可能是 configId 格式`);try{let{promises:o}=await e.A(23970),t=(await e.A(89793)).join(process.cwd(),"data","mcp-configs","configs.json"),r=await o.readFile(t,"utf-8");if(JSON.parse(r).some(e=>e.id===n)){let e=`proxy_${n}`;console.log(`  ✅ [Call Tool] 配置存在，确认是代理连接`),console.log(`  - 自动转换为: ${e}`),a=!0,i=e}else console.log(`  ⚠️  配置不存在，不是代理连接`)}catch(e){console.log(`  ⚠️  检查配置失败: ${e.message}`)}}if(!a&&n.startsWith("conn_")){console.log(`  - connectionId 是 conn_xxx 格式，检查是否有活跃的代理会话`);let e=(0,y.getActiveProxyConfigIds)();if(console.log(`  - 活跃的代理配置: ${e.join(", ")||"无"}`),e.length>0){let o=e[0],t=`proxy_${o}`;console.log(`  ✅ 检测到活跃代理会话，自动识别为代理连接`),console.log(`  - 使用配置: ${o}`),console.log(`  - 自动转换为: ${t}`),a=!0,i=t}else console.log(`  ⚠️  没有活跃的代理会话`)}}if(console.log(`
[Call Tool] 连接类型检查:`),console.log(`  - 原始 connectionId: "${n}"`),console.log(`  - 实际使用的 connectionId: "${i}"`),console.log(`  - 是否是代理连接: ${a}`),console.log(`  - 是否以 "proxy_" 开头: ${i.startsWith("proxy_")}`),a)try{t=(0,y.getProxyClient)(i),console.log(`  ✅ 使用现有代理会话`)}catch(h){let o;console.log(`  ⚠️  代理会话不存在，尝试创建临时会话...`);let n=i.replace("proxy_",""),{promises:r}=await e.A(23970),l=(await e.A(89793)).join(process.cwd(),"data","mcp-configs","configs.json"),s=await r.readFile(l,"utf-8"),a=JSON.parse(s).find(e=>e.id===n);if(!a)throw Error(`配置不存在: ${n}`);let{Client:c}=await e.A(95546),{StdioClientTransport:u}=await e.A(89980),{SSEClientTransport:d}=await e.A(17361),p=new c({name:"mcp-proxy-server",version:"1.0.0"},{capabilities:{tools:{},prompts:{},resources:{}}}),g=a.connectionConfig||{};if("url"===a.connectionType&&g.url){let e=new URL(g.url);o=new d(e)}else if("command"===a.connectionType&&g.command)o=new u({command:g.command,args:g.args||[]});else if("script"===a.connectionType&&g.script){let e="string"==typeof g.script?JSON.parse(g.script):g.script,t=e.url||e.sse||e.server&&e.server.url;if(t)o=new d(new URL(t));else throw Error("脚本中未找到有效的URL")}else throw Error(`不支持的连接类型: ${a.connectionType}`);await p.connect(o),t=p,console.log(`  ✅ 临时代理会话创建成功`)}else t=(0,R.getClient)(i);console.log(`
[Call Tool] 调用工具: ${r}`);let c=await t.callTool({name:r,arguments:l||{}});console.log(`  ✅ 工具调用成功`),console.log(`
[Call Tool] 检查是否需要分发代币:`),console.log(`  - 是代理连接: ${a}`),console.log(`  - 有钱包地址: ${!!s}`),console.log(`  - 条件满足: ${a&&!!s}`);let u=null;if(a&&s){console.log(`
[Call Tool] ✅ 开始代币分发流程...`),console.log(`  - 钱包地址: ${s}`),console.log(`  - 准备调用 /api/distribute-tokens`);try{let e=`${o.nextUrl.origin}/api/distribute-tokens`;console.log(`  - 分发API URL: ${e}`);let t=await fetch(e,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({result:c,walletAddress:s})});console.log(`  - 分发API响应状态: ${t.status}`);let n=await t.json();console.log(`  - 分发API响应数据:`,JSON.stringify(n,null,2)),n.success?(u={success:!0,amount:n.amount,valueHash:n.valueHash,authorizeTxHash:n.authorizeTxHash,distributeTxHash:n.distributeTxHash},console.log(`  ✅ [Call Tool] 代币分发成功: ${n.amount} 代币`)):(console.error(`  ❌ [Call Tool] 代币分发失败:`,n.error||n.message),u={success:!1,error:n.error||n.message})}catch(e){console.error(`  ❌ [Call Tool] 代币分发异常:`),console.error(`    - 错误类型: ${e.constructor.name}`),console.error(`    - 错误消息: ${e.message}`),e.stack&&console.error(`    - 错误堆栈:
${e.stack}`),u={success:!1,error:e.message}}}else console.log(`
[Call Tool] ⚠️  跳过代币分发:`),a||console.log(`  - 原因: 不是代理连接 (connectionId: ${n})`),s||console.log(`  - 原因: 未提供钱包地址`);return console.log(`
========== [Call Tool API] 请求完成 ==========
`),v.NextResponse.json({success:!0,result:c,tokenDistribution:u})}catch(e){return console.error("\n========== [Call Tool API] 请求失败 =========="),console.error("调用工具失败:",e),console.error(`错误类型: ${e.constructor.name}`),console.error(`错误消息: ${e.message}`),e.stack&&console.error(`错误堆栈:
${e.stack}`),console.error("==========================================\n"),v.NextResponse.json({error:"调用工具失败",message:e.message},{status:500})}}e.s(["POST",()=>C],84997);var T=e.i(84997);let $=new o.AppRouteRouteModule({definition:{kind:t.RouteKind.APP_ROUTE,page:"/api/call-tool/route",pathname:"/api/call-tool",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/new-flow/AINO/app/api/call-tool/route.ts",nextConfigOutput:"",userland:T}),{workAsyncStorage:E,workUnitAsyncStorage:A,serverHooks:P}=$;function _(){return(0,n.patchFetch)({workAsyncStorage:E,workUnitAsyncStorage:A})}async function I(e,o,n){$.isDev&&(0,r.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let v="/api/call-tool/route";v=v.replace(/\/index$/,"")||"/";let R=await $.prepare(e,o,{srcPage:v,multiZoneDraftMode:!1});if(!R)return o.statusCode=400,o.end("Bad Request"),null==n.waitUntil||n.waitUntil.call(n,Promise.resolve()),null;let{buildId:y,params:C,nextConfig:T,parsedUrl:E,isDraftMode:A,prerenderManifest:P,routerServerContext:_,isOnDemandRevalidate:I,revalidateOnlyGenerated:N,resolvedPathname:S,clientReferenceManifest:b,serverActionsManifest:O}=R,H=(0,i.normalizeAppPath)(v),j=!!(P.dynamicRoutes[H]||P.routes[S]),U=async()=>((null==_?void 0:_.render404)?await _.render404(e,o,E,!1):o.end("This page could not be found"),null);if(j&&!A){let e=!!P.routes[S],o=P.dynamicRoutes[H];if(o&&!1===o.fallback&&!e){if(T.experimental.adapterPath)return await U();throw new w.NoFallbackError}}let k=null;!j||$.isDev||A||(k="/index"===(k=S)?"/":k);let M=!0===$.isDev||!j,q=j&&!M;O&&b&&(0,s.setReferenceManifestsSingleton)({page:v,clientReferenceManifest:b,serverActionsManifest:O,serverModuleMap:(0,a.createServerModuleMap)({serverActionsManifest:O})});let D=e.method||"GET",F=(0,l.getTracer)(),L=F.getActiveScopeSpan(),K={params:C,prerenderManifest:P,renderOpts:{experimental:{authInterrupts:!!T.experimental.authInterrupts},cacheComponents:!!T.cacheComponents,supportsDynamicResponse:M,incrementalCache:(0,r.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:T.cacheLife,waitUntil:n.waitUntil,onClose:e=>{o.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(o,t,n)=>$.onRequestError(e,o,n,_)},sharedContext:{buildId:y}},J=new c.NodeNextRequest(e),W=new c.NodeNextResponse(o),B=u.NextRequestAdapter.fromNodeNextRequest(J,(0,u.signalFromNodeResponse)(o));try{let s=async e=>$.handle(B,K).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":o.statusCode,"next.rsc":!1});let t=F.getRootSpanAttributes();if(!t)return;if(t.get("next.span_type")!==d.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${t.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let n=t.get("next.route");if(n){let o=`${D} ${n}`;e.setAttributes({"next.route":n,"http.route":n,"next.span_name":o}),e.updateName(o)}else e.updateName(`${D} ${v}`)}),a=!!(0,r.getRequestMeta)(e,"minimalMode"),i=async r=>{var l,i;let c=async({previousCacheEntry:t})=>{try{if(!a&&I&&N&&!t)return o.statusCode=404,o.setHeader("x-nextjs-cache","REVALIDATED"),o.end("This page could not be found"),null;let l=await s(r);e.fetchMetrics=K.renderOpts.fetchMetrics;let i=K.renderOpts.pendingWaitUntil;i&&n.waitUntil&&(n.waitUntil(i),i=void 0);let c=K.renderOpts.collectedTags;if(!j)return await (0,g.sendResponse)(J,W,l,K.renderOpts.pendingWaitUntil),null;{let e=await l.blob(),o=(0,h.toNodeOutgoingHttpHeaders)(l.headers);c&&(o[m.NEXT_CACHE_TAGS_HEADER]=c),!o["content-type"]&&e.type&&(o["content-type"]=e.type);let t=void 0!==K.renderOpts.collectedRevalidate&&!(K.renderOpts.collectedRevalidate>=m.INFINITE_CACHE)&&K.renderOpts.collectedRevalidate,n=void 0===K.renderOpts.collectedExpire||K.renderOpts.collectedExpire>=m.INFINITE_CACHE?void 0:K.renderOpts.collectedExpire;return{value:{kind:x.CachedRouteKind.APP_ROUTE,status:l.status,body:Buffer.from(await e.arrayBuffer()),headers:o},cacheControl:{revalidate:t,expire:n}}}}catch(o){throw(null==t?void 0:t.isStale)&&await $.onRequestError(e,o,{routerKind:"App Router",routePath:v,routeType:"route",revalidateReason:(0,p.getRevalidateReason)({isStaticGeneration:q,isOnDemandRevalidate:I})},_),o}},u=await $.handleResponse({req:e,nextConfig:T,cacheKey:k,routeKind:t.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:P,isRoutePPREnabled:!1,isOnDemandRevalidate:I,revalidateOnlyGenerated:N,responseGenerator:c,waitUntil:n.waitUntil,isMinimalMode:a});if(!j)return null;if((null==u||null==(l=u.value)?void 0:l.kind)!==x.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==u||null==(i=u.value)?void 0:i.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});a||o.setHeader("x-nextjs-cache",I?"REVALIDATED":u.isMiss?"MISS":u.isStale?"STALE":"HIT"),A&&o.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let d=(0,h.fromNodeOutgoingHttpHeaders)(u.value.headers);return a&&j||d.delete(m.NEXT_CACHE_TAGS_HEADER),!u.cacheControl||o.getHeader("Cache-Control")||d.get("Cache-Control")||d.set("Cache-Control",(0,f.getCacheControlHeader)(u.cacheControl)),await (0,g.sendResponse)(J,W,new Response(u.value.body,{headers:d,status:u.value.status||200})),null};L?await i(L):await F.withPropagatedContext(e.headers,()=>F.trace(d.BaseServerSpan.handleRequest,{spanName:`${D} ${v}`,kind:l.SpanKind.SERVER,attributes:{"http.method":D,"http.target":e.url}},i))}catch(o){if(o instanceof w.NoFallbackError||await $.onRequestError(e,o,{routerKind:"App Router",routePath:H,routeType:"route",revalidateReason:(0,p.getRevalidateReason)({isStaticGeneration:q,isOnDemandRevalidate:I})}),j)throw o;return await (0,g.sendResponse)(J,W,new Response(null,{status:500})),null}}e.s(["handler",()=>I,"patchFetch",()=>_,"routeModule",()=>$,"serverHooks",()=>P,"workAsyncStorage",()=>E,"workUnitAsyncStorage",()=>A],29980)},23970,e=>{e.v(o=>Promise.all(["server/chunks/[externals]_fs_54ffce70._.js"].map(o=>e.l(o))).then(()=>o(22734)))},89793,e=>{e.v(e=>Promise.resolve().then(()=>e(14747)))},95546,e=>{e.v(e=>Promise.resolve().then(()=>e(31584)))},89980,e=>{e.v(e=>Promise.resolve().then(()=>e(97831)))},17361,e=>{e.v(e=>Promise.resolve().then(()=>e(2913)))}];

//# sourceMappingURL=%5Broot-of-the-server%5D__9fba86ac._.js.map